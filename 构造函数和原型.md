在es6之前, 对象不是基于类创建的, 而是利用构造函数来定义对象和它的特征

## 1. 创建对象的三种方法

```js
// 利用 new Object()
var obj1 = new Object()


// 理由字面量创建
var obj2 = {}


// 利用构造函数

// 首字母大写
// 要和new关键字一起使用
function Person(name, age) {
  this.name = name
  this,age = age
  this.skill = function() {
    console.log('111')
  }
}
var obj3 = new Person('wanghan', 26)
```


## 2. new关键字做的事情

      1. 在内存中创建一个新的空对象
      2. 让this指向这个新的空对象
      3. 执行构造函数里面的代码, 为新对象添加属性和方法
      4. 返回这个新对象(所以构造函数里面不需要使用return)


## 3. 构造函数的实例成员和静态成员

  **实例成员**
  
  1. 就是构造函数内部通过this添加的成员, 例如上面的 name , age 等就是实例成员
  2. 实例成员只能通过实例化的对象来访问
  
  ```js
   console.log(Person.name) // undefined
   console.log(obj3.name) // wanghan
  ```
  
  **静态成员**
  
  1. 就是构造函数本身上添加的成员
  2. 静态成员不能通过对象来访问, 只能通过构造函数访问
  
  ```js
   Person.sex = 'man'
   console.log(Person.sex) // man
  ```


## 4. 构造函数存在的问题

  1. 构造函数里面的方法, 存在内存浪费的问题
  
    因为函数是复杂数据类型, 所以每new一个对象, 内存都会开辟一个新的空间去存储方法, 如果构造函数的方法特别多, 就会造成非常大的浪费


## 5. 构造函数的原型对象 prototype

  1. 共享的 所有通过构造函数的new出来的对象所共享的
  2. 每一个构造函数都有一个prototype属性, prototype是一个对象, 这个对象的所有属性和方法, 都会被构造函数所拥有
  3. 我们可以把一些不变的方法直接定义在prototype对象上, 这样对象的实例就可以共享, 也不会开辟新的内存空间, 不会造成内存浪费
























